# 分布式事务漫谈

数据库的一大特点是支持事务。事务的四个特性：ACID，本质上是为了保证数据管理不那么混乱，以及保证用户的正常使用。试想，如果一次事务进行到一半要进行回滚，但是数据库却因为代码问题没有办法进行回滚，那么试想留下来的数据有多么丑陋和凌乱，非常难以整理。

## A 原子性

主要保证事务要么全部成功，要么全部失败。这个能力可以由业务开发处理，比如使用TCC框架，但是对业务侵入比较深。也可以由数据库来处理，这样就能简化业务代码。因此你知道为啥TiKV介绍的时候都提支持事务了吧，因为其实多写了一层抽象层，而很多存储系统为了效率和工程上实现的难度，没有支持这个特性。

由数据库来处理的话，普遍有2PC。聪明的你当然猜出来还有1PC, 3PC，不过普遍使用的还是2PC。而2PC一直被人诟病的原因就是，性能不行。当然，各大分布式数据库对它有很多优化。比如TiDB采取的是buffer your writes的方式，把事务中的写操作缓存在TiDB的内存中，在提交的时候使用Percolator来保证原子性。但是这样的问题是会使得事务不再是可交互的事务了，可能会和MySQL产生一些业务逻辑上的不同。这样做的好处是使用缓存来避免等待写入操作达成共识的时间。

Percolator非常巧妙，通过区分primary key和secondary key，把最终commit过程给硬生生降成原子性的过程，并且由异步线程去处理secondary key的commit。

而小强DB的做法是Pipeline和并行提交。也就是说第一把事务里的写给改成异步的（不等待共识算法的完成），第二是在事务还没提交的时候，就维护一个事务记录，等到prepare阶段收到所有节点的yes之后立刻返回客户端，提交交给异步线程。



## C 一致性
这个一致性，很多人会和一致性算法，数据一致性弄混，其实应该不是的。那怎么理解呢？有个知乎答案说，这个一致性C，其实是数据库系统保证：应用系统从一个正确的状态到另一个正确的状态。而ACID就是说事务能够通过AID来保证这个C的过程。C是目的，AID都是手段。比如说你转账100元，如果你账户只有90元是不能转账成功的，这是地球人的常识。但是从外星人的角度来看，可能就觉得难以理解，为什么转账不成功呢？为什么转账的钱就要小于等于自己拥有的金额呢？所以，这个是我们当前业务系统的特殊需求，数据库通过AID来一直保证所有数据都在正确的状态下。
具体可以参考这个问题，在知乎上有比较广泛的探讨：


## I 隔离性

隔离性最早提出是在ANSI SQL 92。当时提出了四种隔离级别，这4种是我们耳熟能详的八股文中的四种。后来有个大神发了篇Critique，就是抨击这四种，觉得分的太少了，没考虑全。于是提出了6种隔离级别和8种读写问题，其中就有快照隔离(SI)和写倾斜。写倾斜概念比较难理解，这个名字翻译的不是很好，不知所云。但有个例子记住就好了：你和小王这周on call，系统要求至少有1个人on call。假设你突然要请假，于是你启动一个请假事务。因为事务启动时检测到有2个人，所以你的请假事务是可以提交成功的。假设在你请假事务执行的时候，小王也请假，然后也检测到有2个人，所以他的请假事务也是可以提交成功的。这样2个事务都提交成功了，违反了系统中至少有1个人on call的约束，于是你们部门就被批评了。这种情况在Searializbe里是不会发生的，但是SI隔离级别却会，被称为写倾斜。

## D 持久性
持久性代表数据库容错的能力，主要的实现手段可以分情况讨论（硬盘有无损坏）。
1. 假设硬盘无损坏：正常事务，写内存和WAL即可。

这里多讲一下WAL。很多人可能觉得是先写WAL，然后再写内存，其实不是的。
WAL应该和内存写是互相异步的。以MySQL举例，BEGIN之后，执行器调用存储引擎接口把数据拿到内存里计算，同时写WAL。众所周知，MySQL一般要写redo log 和 binlog 2种日志。写binlog是先写到buffer里，然后事务COMMIT的时候刷盘。写redo log也差不多，prepare的时候写进buffer。两者不同的点在于binlog是必须要一次性写入的，而redo log是有后台线程在不断刷磁盘，所以日志不连续。但是不过如果设置nnodb_flush_log_at_trx_commit = 1，那么prepare的时候就不仅仅要写Buffer，还要做持久化。这样的话，最终等Binlog写完后，redo log不用再强制持久化一次（更改COMMIT状态）。

2. 假设硬盘损坏：
a. 单体自带的复制，比如Mysql主从复制
b. Raft/Paxos维护副本一致性
c. Aurora共享存储

正是因为2种情况都考虑了，所以数据库才具有了D。

## 总结
后续会update一些A和I的内容。