# TiDB 2020 Hackathon 项目速览

本文的目的在于用简短的几句话通俗地解释各个项目要做啥。

## Xteam - 基于Region级别的follower read优化
TiKV有个选项叫做follower read，开启后能使用副本分担读请求（之前的读写请求都要由leader负责）。它的作用域为每个session，也就是说开启后，当前client的读请求可以打到follower上。但是，follower read并不是零成本的，因为在实习上每次follower read发起，follower都需要发一次RPC向leader节点询问当前的执行进度，这会产生一次额外的网络请求开销。这同样带来一个问题：是否同一个Session的所有Region都适合开启follower read？如果我们增加对某部分热点Region的follower Read选项，是否会增强数据库的性能？

## TiFS
一个用户态文件系统(FUSE)。传统的文件系统都是用内核态的code写的，调试比较麻烦。现在，我们可以基于libfuse([C library](https://github.com/libfuse/libfuse/))，把打到内核态的函数调用(比如open一个文件，传统办法会进入内核执行，但是利用这个库，内核线程只传递信号给用户态线程，提醒它去执行对应操作)转化成用户态的文件操作调用，所以用户只需编写用户态的代码即可实现文件系统。这个组用Rust写的，基于一个rs版的[libfuse] (https://github.com/cberner/fuser)，然后调用TiKV的api实现用户态的分布式存储系统。

## ' or 0=0 or ' (UDF)

> 用户可使用 Golang、Rust、C、C++ 等语言编写自定义逻辑的程序，使用我们提供的工具链转编译到 WebAssembly 字节码后，通过以下方式加载到 TiDB 数据库：
```
CREATE FUNCTION [name] WASM_BYTECODE [bytecode_binary];
```

TiDB/TiKV收到bytecode_binary后，使用LLVM等技术编译为当前平台原生指令后执行。同时这些指令还将缓存在本地，提升性能。不仅仅实现了功能，还做了下推的优化。TiDB在给TiKV下推UDF字节码时，先下推ID，若TiKV本地没有则重新下推完整字节码。TiKV 收到字节码后，将字节码存储在本地并编译，后续不再需要该函数的字节码。

感觉RFC写的很详细。

## 
