#! https://zhuanlan.zhihu.com/p/258931710
# 白话一致性


首先，当我们讲一致性的时候，我们要明确我们看问题的角度。比如强一致性，它到底是数据层面还是操作层面的定义？不同的定义会带给我们不同的回答。本文从2个角度来分析常见的一致性模型，并且讲一些实际例子。

## 数据层面 


### 强一致性
这里我把强一致性定义在数据层面。由于在分布式环境下，不同数据副本分布在不同机器上，所以受物理条件约束，更新总会有延迟，不可能完全同步。因此，我这里讲的强一致性，是指主节点收到写入请求后，必须等待所有从节点成功写入再返回客户端写成功。比如MySQL的全同步复制(Fully Synchronous Replication)。

这里在数据层面保证了强一致性。因为当MySQL可以返回客户端写成功时，就真的代表所有副本的值都已经同步到最新了。但实际生产中，这样维护的成本过大。第一个是写入延迟，第二个是它保证的一致性其实多余了。我并不需要在数据层面保证强一致，只要读写没问题就行。

### 最终一致性
这里就是大多数分布式系统采取的方案。比如利用Raft做状态复制的系统，超过半数节点写入成功就返回给客户端写成功。但是在数据层面上，各个副本并不一定达到了一致。比如某个Raft Follower一直拒绝Leader的AppendEntries RPC，导致一直重试写入。这会有一个时间间隔，但是最终都能达到一致的。
既然大多数分布式系统采取了这个方案，但是读写一致性又是强需求，那么怎么保证永远不会读到过期的数据呢？Raft是从读写策略这个层面上解决的，当然还有Quorum模型。

## 操作层面
其实大家也可以发现，如果我们从数据层面去定义一致性，其实没什么太大意义。因为用户最关心的永远是它读取时候的一致性，只要TA感觉你这个数据库提供的一致性正确，你的一致性就达标了，并不关心每个副本是否达到一致，何时达到一致，后面这些问题要由系统设计者来关心。因此接下来从操作层面去定义一致性。
### 写后读一致性
对于用户体验影响非常大。设想你发了朋友圈，那么一般会刷新自己的朋友圈看有没有显示。如果你发现没有显示，你一定觉得这是个辣鸡软件。还有比如知乎的想法评论功能，就是一个代表，经常我评论完了别人的想法，往往要过一会才看到评论数+1，这个相比Twitter差远了。

这个的实现方案，要达到读写分离，一般是用时间戳来标识不同时间段的数据，以确保最新。具体还是比较复杂，这里暂时不详细探讨。

### 单调读一致性
多次读同一份数据，不可能读到更老的数据。怎么理解这个呢？其实就比如说你作为男朋友，发了一条秀恩爱的票圈。你女朋友刷新看到了很高兴，再刷新的时候就刷没了，以为是你故意删除（其实你啥都没做），瞬间转喜为怒，这就不好了。那具体的原因其实就是有系统没保证单调读一致性。假设那条票圈需要写入一个基于主从的分布式数据库，但是部分从节点还没写完。你女票一开始刷新的时候是查询已经写完的从节点，能查到数据。但是如果之后查询请求路由到了没写完的从节点，那么就暂时查不到数据，造成了一种时钟回拨的假象，也就造成了如上的车祸现场。

深究原因，是因为用户请求的副本不固定，造成了这种问题。解决方案就是固定化同一个用户请求的副本，比如通过用户ID来计算哈希，选择固定的副本，而不是随机选择。


### 前缀一致性
朋友圈评论。A评论B，然后B回复A。这2条消息是有严格顺序的。比如说你评论问远在北美的老王吃了没，老王回你刚吃了“麦当劳”。如果你刷新的时候看到老王先回复你“刚吃了麦当劳”，你的问句反而在他下面，那就是违背了前缀一致性。
具体原因可以是如下：你在国内，消息最先写入的数据库在国内，老王的回复最先写入到北美。这2条消息是要保证严格的因果关系的（因为必然是你先问老王，老王才会回复你）。假设这是一个全球分布式数据库的问题，而且物理上不存在绝对时间，只能逼近。那如果在你刷新的时候，国内数据库接到查询，它同步北美的消息的时候把这2条消息的时间顺序弄反了，那么就会出现之前说的这种情况。

DDIA说这种问题产生的源头主要是数据库分区。分区的数据库没有一个机制确保写入的顺序，于是就造成了消息的乱序。解决方案是具有因果顺序的写入都交给一个分区来完成，不过很显然，这样会带来效率的大打折扣。


### 线性一致性
任何写操作仿佛写在一个副本上。