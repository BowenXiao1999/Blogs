# 白话一致性

自己总结的一致性。之前看过很多讲一致性的，大多比较零散，故献丑重新总结一下。

首先，当我们讲一致性的时候，我们要明确我们看问题的角度。比如强一致性，它到底是数据层面还是操作层面的定义？不同的定义会带给我们不同的回答。本文从2个角度来分析常见的一致性模型，并且讲一些实际例子。

## 数据层面


### 强一致性
这里我把强一致性定义在数据层面。由于在分布式环境下，不同数据副本分布在不同机器上，所以受物理条件约束，更新总会有延迟，不可能完全同步。因此，我这里讲的强一致性，是指主节点收到写入请求后，必须等待所有从节点成功写入再返回客户端写成功。比如MySQL的全同步复制(Fully Synchronous Replication)。

这里在数据层面保证了强一致性。因为当MySQL可以返回客户端写成功时，就真的代表所有副本的值都已经同步到最新了。但实际生产中，这样维护的成本过大。第一个是写入延迟，第二个是它保证的一致性其实多余了。我并不需要在数据层面保证强一致，只要读写没问题就行。

### 最终一致性
这里就是大多数分布式系统采取的方案。比如利用Raft做状态复制的系统，超过半数节点写入成功就返回给客户端写成功。但是在数据层面上，各个副本并不一定达到了一致。比如某个Raft Follower一直拒绝Leader的AppendEntries RPC，导致一直重试写入。这会有一个时间间隔，但是最终都能达到一致的。

既然大多数分布式系统采取了这个方案，但是读写一致性又是强需求，那么怎么保证永远不会读到过期的数据呢？Raft是从读写策略这个层面上解决的，当然还有Quorum模型。

## 操作层面
### 写后读一致性
对于用户体验影响非常大。设想你发了朋友圈，那么一般会刷新自己的朋友圈看有没有显示。

### 单调读一致性
多次读同一份数据，不可能读到更老的数据。

### 前缀一致性
朋友圈评论。A评论B，然后B回复A。这2条消息是有严格顺序的。那么如果消息写入的地点相差很多（比如一个在北美一个在国内），那么就有可能出现顺序错误的情况。

### 线性一致性
任何写操作仿佛写在一个副本上。